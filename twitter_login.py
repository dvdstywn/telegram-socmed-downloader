import asyncio
import os
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Ensure accounts directory exists
os.makedirs("./accounts", exist_ok=True)

async def save_session_data(page, filename_prefix):
    """Save cookies for later use"""
    try:
        # Save cookies only (localStorage causes security issues)
        cookies = await page.context.cookies()

        # Save in Netscape format
        cookies_path = f"./tmp/{filename_prefix}_cookies.txt"
        with open(cookies_path, "w") as f:
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# https://curl.haxx.se/rfc/cookie_spec.html\n")
            f.write("# This file was generated by twitter_login.py\n\n")
            for cookie in cookies:
                # Format: domain flag path secure expiration name value
                domain = cookie.get('domain', '')
                flag = 'TRUE' if cookie.get('httpOnly', False) else 'FALSE'
                path = cookie.get('path', '/')
                secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                expiration = str(int(cookie.get('expires', 0))) if cookie.get('expires', 0) > 0 else '0'
                name = cookie.get('name', '')
                value = cookie.get('value', '')

                # Only write cookies with valid domains and names
                if domain and name:
                    f.write(f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}\n")

        print(f"üç™ Cookies saved in Netscape format to ./tmp/{filename_prefix}_cookies.txt")
        return True
    except Exception as e:
        print(f"‚ùå Error saving session data: {e}")
        return False

async def load_session_data(page, filename_prefix):
    """Load cookies from saved files"""
    try:
        # Load cookies from Netscape format file
        cookies_path = f"./tmp/{filename_prefix}_cookies.txt"

        # Parse Netscape format cookies file
        cookies = []
        with open(cookies_path, "r") as f:
            for line in f:
                # Skip comments and empty lines
                if line.startswith('#') or line.strip() == '':
                    continue

                # Parse the tab-separated fields
                parts = line.strip().split('\t')
                if len(parts) >= 7:  # Should have at least 7 fields
                    cookie = {
                        'domain': parts[0],
                        'httpOnly': parts[1] == 'TRUE',
                        'path': parts[2],
                        'secure': parts[3] == 'TRUE',
                        'expires': int(parts[4]) if parts[4].isdigit() else 0,
                        'name': parts[5],
                        'value': parts[6]
                    }
                    cookies.append(cookie)

        await page.context.add_cookies(cookies)

        print(f"üìÇ Session data loaded from ./tmp/{filename_prefix}_cookies.txt")
        return True
    except FileNotFoundError:
        print(f"üìÇ No saved session data found for {filename_prefix} in ./tmp directory")
        return False
    except Exception as e:
        print(f"‚ùå Error loading session data: {e}")
        return False

async def is_logged_in(page):
    """Check if user is already logged in by looking for user-specific elements"""
    try:
        # Check for user profile link or home link that indicates logged-in state
        await page.wait_for_selector('a[href="/home"]', timeout=5000)
        # Also check for user profile elements
        await page.wait_for_selector('a[aria-label="Profile"]', timeout=5000)
        return True
    except:
        return False

async def login_to_twitter(username: str, password: str, headless: bool = True, use_session_data: bool = True):
    """
    Log into Twitter using Playwright with session data persistence

    Args:
        username (str): Twitter username or email
        password (str): Twitter password
        headless (bool): Whether to run browser in headless mode
        use_session_data (bool): Whether to use saved session data if available

    Returns:
        tuple: (page, browser, playwright) if successful, (None, None, None) if failed
    """
    # Launch browser
    p = await async_playwright().start()
    browser = await p.chromium.launch(headless=headless)
    page = await browser.new_page()

    # Try to load saved session data if requested
    if use_session_data:
        print("üîç Checking for saved session data...")
        if await load_session_data(page, "twitter_session"):
            # Navigate to Twitter home page to verify login status
            await page.goto("https://twitter.com/home")
            if await is_logged_in(page):
                print("‚úÖ Already logged in using saved session data!")
                return page, browser, p
            else:
                print("‚ö†Ô∏è Saved session data is invalid or expired")

    try:
        # Navigate to Twitter login page
        await page.goto("https://twitter.com/login")
        print("üåê Navigated to Twitter login page")

        # Wait for the username field and fill it
        await page.wait_for_selector('input[autocomplete="username"]', timeout=15000)
        await page.fill('input[autocomplete="username"]', username)
        print("üë§ Filled username")

        # Click the "Next" button
        await page.click('button:has-text("Next")')
        print("üñ±Ô∏è Clicked Next")

        # Wait for password field and fill it
        await page.wait_for_selector('input[name="password"]', timeout=15000)
        await page.fill('input[name="password"]', password)
        print("üîí Filled password")

        # Click the login button
        await page.click('button:has-text("Log in")')
        print("üöÄ Clicked Log in")

        # Wait for navigation to complete
        await page.wait_for_load_state("domcontentloaded", timeout=15000)

        # Check if login was successful
        if await is_logged_in(page):
            print("üéâ Login successful!")
            # Save session data for future use
            await save_session_data(page, "twitter_session")
            return page, browser, p
        else:
            print("‚ö†Ô∏è Login may have failed. Checking for error messages...")
            # Check for error messages
            error_elements = await page.query_selector_all('div[role="alert"]')
            for element in error_elements:
                error_text = await element.text_content()
                if error_text:
                    print(f"‚ùå Error message: {error_text}")
            return None, None, None

    except PlaywrightTimeoutError as e:
        print(f"‚è∞ Timeout error during login: {e}")
        return None, None, None
    except Exception as e:
        print(f"üí• Error during login: {e}")
        return None, None, None


async def main():
    # Get credentials from environment variables (loaded from .env file)
    username = os.getenv("TWITTER_USERNAME")
    password = os.getenv("TWITTER_PASSWORD")

    if not username or not password:
        print("‚ùå Please set TWITTER_USERNAME and TWITTER_PASSWORD in your .env file")
        return

    print("üöÄ Starting Twitter login...")

    # Attempt login
    page, browser, playwright = await login_to_twitter(username, password, headless=True, use_session_data=True)

    # Close browser immediately after session creation
    if browser:
        await browser.close()
    if playwright:
        await playwright.stop()

    if page:
        print("‚úÖ Login successful! Session data saved. Browser closed.")
    else:
        print("‚ùå Login failed")


if __name__ == "__main__":
    asyncio.run(main())
