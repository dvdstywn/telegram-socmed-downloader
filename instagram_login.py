import asyncio
import os
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Ensure accounts directory exists
os.makedirs("./accounts", exist_ok=True)

async def save_session_data(page, filename_prefix):
    """Save cookies for later use"""
    try:
        # Save cookies only (localStorage causes security issues)
        cookies = await page.context.cookies()

        # Save in Netscape format for gallery-dl
        netscape_cookies_path = f"./accounts/{filename_prefix}_cookies.txt"
        with open(netscape_cookies_path, "w") as f:
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# https://curl.haxx.se/rfc/cookie_spec.html\n")
            f.write("# This file was generated by instagram_login.py\n\n")
            for cookie in cookies:
                # Format: domain flag path secure expiration name value
                domain = cookie.get('domain', '')
                flag = 'TRUE' if cookie.get('httpOnly', False) else 'FALSE'
                path = cookie.get('path', '/')
                secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                expiration = str(int(cookie.get('expires', 0))) if cookie.get('expires', 0) > 0 else '0'
                name = cookie.get('name', '')
                value = cookie.get('value', '')

                # Only write cookies with valid domains and names
                if domain and name:
                    f.write(f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}\n")

        print(f"üç™ Cookies saved in Netscape format to ./accounts/{filename_prefix}_cookies.txt")
        return True
    except Exception as e:
        print(f"‚ùå Error saving session data: {e}")
        return False

async def load_session_data(page, filename_prefix):
    """Load cookies from saved files"""
    try:
        # Load cookies from Netscape format file
        cookies_path = f"./accounts/{filename_prefix}_cookies.txt"

        # Parse Netscape format cookies file
        cookies = []
        with open(cookies_path, "r") as f:
            for line in f:
                # Skip comments and empty lines
                if line.startswith('#') or line.strip() == '':
                    continue

                # Parse the tab-separated fields
                parts = line.strip().split('\t')
                if len(parts) >= 7:  # Should have at least 7 fields
                    cookie = {
                        'domain': parts[0],
                        'httpOnly': parts[1] == 'TRUE',
                        'path': parts[2],
                        'secure': parts[3] == 'TRUE',
                        'expires': int(parts[4]) if parts[4].isdigit() else 0,
                        'name': parts[5],
                        'value': parts[6]
                    }
                    cookies.append(cookie)

        await page.context.add_cookies(cookies)

        print(f"üìÇ Session data loaded from ./accounts/{filename_prefix}_cookies.txt")
        return True
    except FileNotFoundError:
        print(f"üìÇ No saved session data found for {filename_prefix} in ./accounts directory")
        return False
    except Exception as e:
        print(f"‚ùå Error loading session data: {e}")
        return False

async def is_logged_in(page):
    """Check if user is already logged in by looking for user-specific elements"""
    try:
        # Check for user profile link or home link that indicates logged-in state
        await page.wait_for_selector('a[href="/"]', timeout=5000)
        return True
    except:
        return False

async def login_to_instagram(username: str, password: str, headless: bool = False, use_session_data: bool = True):
    """
    Log into Instagram using Playwright with session data persistence

    Args:
        username (str): Instagram username or email
        password (str): Instagram password
        headless (bool): Whether to run browser in headless mode
        use_session_data (bool): Whether to use saved session data if available

    Returns:
        tuple: (page, browser, playwright) if successful, (None, None, None) if failed
    """
    # Launch browser with Chrome user agent
    p = await async_playwright().start()
    browser = await p.chromium.launch(headless=headless)
    page = await browser.new_page()
    await page.set_extra_http_headers({
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"
    })

    # Try to load saved session data if requested
    if use_session_data:
        print("üîç Checking for saved session data...")
        if await load_session_data(page, "instagram_session"):
            # Navigate to Instagram home page to verify login status
            await page.goto("https://www.instagram.com/")
            if await is_logged_in(page):
                print("‚úÖ Already logged in using saved session data!")
                return page, browser, p
            else:
                print("‚ö†Ô∏è Saved session data is invalid or expired")

    async def perform_login():
        """Perform the actual login process"""
        # Navigate to Instagram login page
        await page.goto("https://www.instagram.com/accounts/login/")
        print("üåê Navigated to Instagram login page")

        # Wait for the username field and fill it
        await page.wait_for_selector('input[name="username"]', timeout=15000)
        await page.fill('input[name="username"]', username)
        print("üë§ Filled username")

        # Wait for password field and fill it
        await page.wait_for_selector('input[name="password"]', timeout=15000)
        await page.fill('input[name="password"]', password)
        print("üîí Filled password")

        # Click the login button
        await page.click('button[type="submit"]')
        print("üöÄ Clicked Log in")
        current_url = page.url
        print(current_url)

        # Wait for navigation to complete with longer timeout
        await page.wait_for_load_state("domcontentloaded", timeout=30000)

        # Handle different post-login scenarios
        current_url = page.url
        print(f"üìã Current URL after login: {current_url}")

        # Check if we're on the "Save Your Login Info" page (regular login)
        try:
            await page.wait_for_selector('text=Save Your Login Info', timeout=10000)
            print("üíæ Detected 'Save Your Login Info' page")

            # Click the "Save Info" button
            save_info_button = await page.query_selector('button:has-text("Save Info")')
            if save_info_button:
                print("üíæ Clicking 'Save Info' button")
                await save_info_button.click()
            else:
                # If "Save Info" button not found, try "Not Now" button
                not_now_button = await page.query_selector('button:has-text("Not Now")')
                if not_now_button:
                    print("‚è≠Ô∏è Clicking 'Not Now' button")
                    await not_now_button.click()

            # Wait for navigation to home page
            await page.wait_for_load_state("domcontentloaded", timeout=30000)
            print("üè† Navigated to home page after saving login info")
        except:
            print("‚è≠Ô∏è Not on 'Save Your Login Info' page or already handled")

        # Check if we're on the "onetap" page (quick login)
        if "accounts/onetap" in current_url:
            print("‚ö° Detected 'One Tap' login page")

            # Click the "Save Info" button
            save_info_button = await page.query_selector('button:has-text("Save Info")')
            if save_info_button:
                print("üíæ Clicking 'Save Info' button")
                await save_info_button.click()
                # Wait for navigation to home page
                await page.wait_for_load_state("domcontentloaded", timeout=30000)
                print("üè† Navigated to home page after one tap login")
            else:
                # If "Save Info" button not found, try "Not Now" button
                not_now_button = await page.query_selector('button:has-text("Not Now")')
                if not_now_button:
                    print("‚è≠Ô∏è Clicking 'Not Now' button")
                    await not_now_button.click()
                    # Wait for navigation to home page
                    await page.wait_for_load_state("domcontentloaded", timeout=30000)
                    print("üè† Navigated to home page after skipping one tap")

    try:
        # Perform initial login
        await perform_login()

        # Check if we're redirected to the main page without being logged in
        # This can happen if we're redirected but not actually logged in
        current_url = page.url
        if current_url == "https://www.instagram.com/" or current_url == "https://www.instagram.com":
            print("üîÑ Redirected to main page, checking login status...")
            # Give some time for the page to load
            await page.wait_for_timeout(5000)
            if not await is_logged_in(page):
                print("‚ö†Ô∏è Not logged in after redirect, attempting login again...")
                await perform_login()

        # Check if login was successful by looking for common elements on the home page
        try:
            # Wait for home page elements with extended timeout
            await page.wait_for_selector('a[href="/"]', timeout=20000)
            print("üéâ Login successful!")
            # Save session data for future use
            await save_session_data(page, "instagram_session")
            return page, browser, p
        except:
            print("‚ö†Ô∏è Login may have failed. Checking for error messages...")
            # Check for error messages
            error_elements = await page.query_selector_all('div[role="alert"]')
            for element in error_elements:
                error_text = await element.text_content()
                if error_text:
                    print(f"‚ùå Error message: {error_text}")

            # Also check for common error indicators
            try:
                error_msg = await page.query_selector('div:has-text("Sorry, your password was incorrect")')
                if error_msg:
                    print("‚ùå Error: Incorrect password")
            except:
                pass

            try:
                error_msg = await page.query_selector('div:has-text("The username you entered")')
                if error_msg:
                    print("‚ùå Error: Invalid username")
            except:
                pass

            return None, None, None

    except PlaywrightTimeoutError as e:
        print(f"‚è∞ Timeout error during login: {e}")
        return None, None, None
    except Exception as e:
        print(f"üí• Error during login: {e}")
        return None, None, None


async def main():
    # Get credentials from environment variables (loaded from .env file)
    username = os.getenv("INSTAGRAM_USERNAME")
    password = os.getenv("INSTAGRAM_PASSWORD")

    if not username or not password:
        print("‚ùå Please set INSTAGRAM_USERNAME and INSTAGRAM_PASSWORD in your .env file")
        return

    print("üöÄ Starting Instagram login...")

    # Attempt login
    page, browser, playwright = await login_to_instagram(username, password, headless=True, use_session_data=True)

    # Close browser immediately after session creation
    if browser:
        await browser.close()
    if playwright:
        await playwright.stop()

    if page:
        print("‚úÖ Login successful! Session data saved. Browser closed.")
    else:
        print("‚ùå Login failed")


if __name__ == "__main__":
    asyncio.run(main())
